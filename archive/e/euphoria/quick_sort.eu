include std/io.e
include std/types.e
include std/text.e
include std/get.e as stdget
include std/sequence.e
include std/math.e

-- Indices for value() return value
enum VALUE_ERROR_CODE, VALUE_VALUE, VALUE_NUM_CHARS_READ

-- Indices for parse_int() return value
enum PARSE_INT_VALID, PARSE_INT_VALUE

function parse_int(sequence s)
    -- Trim off whitespace and parse string
    s = trim(s)
    sequence result = stdget:value(s,, GET_LONG_ANSWER)

    -- Error if any errors, value is not an integer, or any leftover characters
    boolean valid = (
        result[VALUE_ERROR_CODE] = GET_SUCCESS
        and integer(result[VALUE_VALUE])
        and result[VALUE_NUM_CHARS_READ] = length(s)
    )

    -- Get value if invalid
    integer value = 0
    if valid
    then
        value = result[VALUE_VALUE]
    end if

    return {valid, value}
end function

-- Indices for parse_int_list() return value
enum PARSE_INT_LIST_VALID, PARSE_INT_LIST_VALUES

function parse_int_list(sequence s)
    -- Split string on comma
    sequence list = split(s, ",")

    -- Parse each item
    integer valid = FALSE
    sequence values = {}
    for n = 1 to length(list)
    do
        sequence result = parse_int(list[n])
        valid = result[PARSE_INT_VALID]
        values &= result[PARSE_INT_VALUE]
        if not valid
        then
            exit
        end if
    end for

    return {valid, values}
end function

procedure usage()
    puts(
        STDOUT, 
        "Usage: please provide a list of at least two integers to sort in the format \"1, 2, 3, 4, 5\"\n"
    )
    abort(0)
end procedure

procedure show_list_values(sequence values)
    integer n = length(values)
    for k = 1 to n
    do
        if k > 1
        then
            puts(STDOUT, ", ")
        end if

        printf(STDOUT, "%d", {values[k]})
    end for

    if n > 0
    then
        puts(STDOUT, "\n")
    end if
end procedure

-- Indices for partition result
enum PARTITION_LEFT, PARTITION_MID, PARTITION_RIGHT

function quick_sort(sequence values)
    -- Source: https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme

    -- Only sort if enough values
    integer n = length(values)
    if n <= 1
    then
        return values
    end if

    -- Partition array
    sequence result = partition(values)

    -- Sort left side of partition
    sequence left = quick_sort(result[PARTITION_LEFT])

    -- Sort right side of partition
    sequence right = quick_sort(result[PARTITION_RIGHT])

    -- Combine left, middle, and right values
    return left & result[PARTITION_MID] & right
end function

function partition(sequence values)
    -- Choose last value as pivot
    integer pivot = values[$]

    -- Set temporary pivot index
    integer i = 0

    -- Swap elements less than or equal to pivot, and increment temporary index
    integer n = length(values)
    integer temp
    for j = 1 to n - 1
    do
        if values[j] <= pivot
        then
            i += 1
            temp = values[i]
            values[i] = values[j]
            values[j] = temp
        end if
    end for

    -- Move pivot to correct position
    i += 1
    values[$] = values[i]
    values[i] = pivot

    -- Return left values, middle value, and right values
    return {values[1..i - 1], values[i], values[i + 1..$]}
end function

-- Check 1st command-line argument
sequence argv = command_line()
if length(argv) < 4 or length(argv[4]) = 0
then
    usage()
end if

-- Parse 1st command-line argument
sequence result = parse_int_list(argv[4])
sequence values = result[PARSE_INT_LIST_VALUES]
if not result[PARSE_INT_LIST_VALID] or length(values) < 2
then
    usage()
end if

-- Do quick sort and show results
values = quick_sort(values)
show_list_values(values)
